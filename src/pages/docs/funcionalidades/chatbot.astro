---
import DocsLayout from "../../../layouts/DocsLayout.astro";
import DocsBreadcrumb from "../../../components/docs/DocsBreadcrumb.vue";
import DocsSection from "../../../components/docs/DocsSection.vue";
import DocsSubsection from "../../../components/docs/DocsSubsection.vue";
import DocsSteps from "../../../components/docs/DocsSteps.vue";
import DocsCallout from "../../../components/docs/DocsCallout.vue";
import DocsPreview from "../../../components/docs/DocsPreview.vue";
import CodeBlock from "../../../components/docs/CodeBlock.vue";
import Chatbot1 from "@/components/Chatbot.vue";

const toc = [
    { id: "introducao", title: "Introdução", level: 2 },
    { id: "instalacao", title: "Instalação", level: 2 },
    { id: "utilizacao-base", title: "Utilização Base", level: 2 },
    { id: "api", title: "Propriedades e Eventos", level: 2 },
    { id: "componentes-internos", title: "Componentes Internos", level: 2 },
    { id: "estado-logica", title: "Estados e Lógica Interna", level: 2 },
    { id: "design-decisions", title: "Decisões de Design", level: 2 },
    { id: "integracao", title: "Integração com o Projeto", level: 2 },
    { id: "testes-edgecases", title: "Testes e Edge Cases", level: 2 },
    { id: "boas-praticas", title: "Boas Práticas e Recomendações", level: 2 },
    { id: "roadmap", title: "Extensões Futuras / Roadmap", level: 2 },
];

const installationSteps = [
    {
        title: "Instalar dependências",
        description:
            "Instala as dependências necessárias para correr o chatbot e a pública API local utilizada no exemplo.",
        code: "npm install axios lucide-vue-next date-fns",
        language: "bash",
    },
    {
        title: "Adicionar o componente",
        description:
            "Coloca `Chatbot.vue` em `components/` e regista-o onde for necessário (páginas, layouts, etc.).",
        code: "cp components/Chatbot.vue src/components/ui/chatbot/Chatbot.vue",
        language: "bash",
    },
    {
        title: "Configurar endpoint",
        description:
            "Adiciona a rota serverless `pages/api/chat.ts` (ou equivalente) que proxy para a API LLM que usas.",
        code: "touch src/pages/api/chat.ts && # cola o handler fornecido",
        language: "bash",
    },
];

const basicPreview = `<template>
  <div class="h-[600px]">
    <Chatbot />
  </div>
</template>

<script setup lang="ts">
import Chatbot from '@/components/Chatbot.vue'
</script>`;
---

<DocsLayout
    title="Chatbot — Assistente de UCs"
    description="Componente de chat orientado para unidades curriculares (UCs) com integração LLM e pesquisa local em ucs.json."
    toc={toc}
>
    <DocsBreadcrumb
        items={[
            { label: "Documentação", href: "/docs" },
            { label: "Componentes", href: "/docs/componentes" },
            { label: "Chatbot", href: "/docs/componentes/chatbot" },
        ]}
        client:load
    />

    <!-- ============================================================= -->
    <!-- Introdução -->
    <!-- ============================================================= -->
    <DocsSection id="introducao" title="Introdução" client:load>
        <p class="text-lg text-muted-foreground mt-2">
            O componente <strong>Chatbot</strong> fornece uma interface conversacional
            focada em unidades curriculares (UCs). O objetivo principal é permitir
            que estudantes e docentes obtenham respostas rápidas sobre avaliações,
            critérios, docentes e outros metadados presentes no ficheiro <code
                >ucs.json</code
            >, complementando com um modelo LLM para formatação e síntese das
            respostas.
        </p>

        <p class="text-lg text-muted-foreground mt-4">
            A arquitetura combina:
            <ul class="list-disc list-inside mt-2">
                <li>
                    Pesquisa local em <code>ucs.json</code> para identificar a UC
                    alvo;
                </li>
                <li>Normalização e consolidação de avaliações;</li>
                <li>
                    Contextualização do prompt do LLM para garantir respostas
                    factuais e limitadas ao contexto;
                </li>
                <li>Graceful fallback e mensagens de erro amigáveis.</li>
            </ul>
        </p>

        <DocsCallout
            variant="info"
            title="Resumo das funcionalidades"
            client:load
        >
            <ul class="list-disc list-inside mt-2">
                <li>
                    Selecção da UC por sigla ou nome, com sugestões quando
                    houver múltiplas correspondências;
                </li>
                <li>
                    Consolidação automática de avaliações repetidas por período;
                </li>
                <li>Proxy serverless para LLM (endpoint `/api/chat`);</li>
                <li>
                    Histórico de conversa simples e limites de contexto para o
                    LLM;
                </li>
                <li>
                    Mensagens de erro tratadas e indicadores de
                    carregamento/typing.
                </li>
            </ul>
        </DocsCallout>
    </DocsSection>

    <!-- ============================================================= -->
    <!-- Instalação -->
    <!-- ============================================================= -->
    <DocsSection id="instalacao" title="Instalação" client:load>
        <DocsSteps steps={installationSteps} client:load />
        <DocsCallout variant="warning" title="Requisitos" client:load>
            <p>
                O componente assume ambiente baseado em Vite/Nuxt/Astro com
                suporte a Vue 3 (Composition API). O endpoint serverless faz
                fetch para uma API externa (p.e. APIfree). Garante que tens uma
                política de CORS adequada e limites de taxa configurados para
                evitar abuse.
            </p>
        </DocsCallout>
    </DocsSection>

    <!-- ============================================================= -->
    <!-- Utilização Base -->
    <!-- ============================================================= -->
    <DocsSection id="utilizacao-base" title="Utilização Base" client:load>
        <p class="text-muted-foreground mb-4">
            Exemplo mínimo de uso do componente. Este exemplo ilustra a
            integração direta e rápida do chat numa página ou painel.
        </p>

        <DocsPreview
            title="Exemplo: Chatbot incorporado"
            code={basicPreview}
            client:load
        >
            <div
                class="border rounded-lg p-4 text-center text-sm text-muted-foreground"
            >
                Previsualização: incorpora o componente <code
                    >&lt;Chatbot /&gt;</code
                > no teu layout.
            </div>
        </DocsPreview>

        <DocsCallout variant="info" title="Nota sobre dados" client:load>
            <p>
                O componente carrega por defeito os dados de <code
                    >/data/ucs.json</code
                >. Se preferires, podes passar um prop (ex.: <code>ucsData</code
                >) e controlar o carregamento externamente.
            </p>
        </DocsCallout>
    </DocsSection>
    <!-- ============================================================= -->
    <!-- Propriedades e Eventos -->
    <!-- ============================================================= -->
    <DocsSection id="api" title="⚙️ Propriedades e Eventos" client:load>
        <p class="text-lg text-muted-foreground">
            O componente <strong>Chatbot.vue</strong> utiliza o padrão de <em
                >self-contained state</em
            > — todos os estados internos são geridos no próprio componente. No entanto,
            existem várias
            <em>propriedades computadas</em> e <em>eventos internos</em> relevantes
            para extensão, teste ou integração com outros módulos (ex.: registo de
            logs, analítica, etc.).
        </p>

        <h4 class="mt-6 font-semibold">
            Propriedades internas (reactive state)
        </h4>
        <table class="table-auto w-full text-sm mt-4 border-collapse">
            <thead>
                <tr class="border-b text-left">
                    <th class="py-2">Propriedade</th>
                    <th class="py-2">Tipo</th>
                    <th class="py-2">Descrição</th>
                </tr>
            </thead>
            <tbody>
                <tr class="border-b">
                    <td><code>messages</code></td>
                    <td
                        ><code
                            >Ref&lt;Array&lt;<code
                                >&#123; role: string; content: string;
                                timestamp: Date <code>&#125;&gt;&gt;</code
                                ></code
                            >
                            <td
                                >Histórico de mensagens do utilizador e do
                                assistente.</td
                            >
                        </code>
                        <tr class="border-b">
                            <td><code>userInput</code></td>
                            <td><code>Ref&lt;string&gt;</code></td>
                            <td
                                >Conteúdo atual do campo de input do utilizador.</td
                            >
                        </tr>
                        <tr class="border-b">
                            <td><code>fase</code></td>
                            <td
                                ><code>Ref&lt;'selecionar' | 'chat'&gt;</code
                                ></td
                            >
                            <td
                                >Estado de fase atual — define se o bot está a
                                selecionar UC ou em conversa ativa.</td
                            >
                        </tr>
                        <tr class="border-b">
                            <td><code>ucSelecionada</code></td>
                            <td><code>Ref&lt;any | null&gt;</code></td>
                            <td
                                >Unidade curricular atualmente selecionada
                                (objeto do JSON de UCs).</td
                            >
                        </tr>
                        <tr class="border-b">
                            <td><code>loading</code></td>
                            <td><code>Ref&lt;boolean&gt;</code></td>
                            <td
                                >Indica se o chatbot está a aguardar resposta do
                                LLM.</td
                            >
                        </tr>
                        <tr class="border-b">
                            <td><code>isTyping</code></td>
                            <td><code>Ref&lt;boolean&gt;</code></td>
                            <td
                                >Controla a exibição do indicador de
                                "digitando...".</td
                            >
                        </tr>
                        <tr>
                            <td><code>ucsData</code></td>
                            <td><code>Array&lt;any&gt;</code></td>
                            <td
                                >Lista completa das UCs carregadas de <code
                                    >/data/ucs.json</code
                                >.</td
                            >
                        </tr>
                    </td>
                </tr>

                <h4 class="mt-8 font-semibold">
                    Eventos internos e funções utilitárias
                </h4>
                <ul
                    class="list-disc list-inside text-sm text-muted-foreground mt-2"
                >
                    <li>
                        <code>scrollToBottom()</code> — garante que a janela de mensagens
                        rola automaticamente para o fim após nova mensagem.
                    </li>
                    <li>
                        <code>normalize(str)</code> — remove acentuação e converte
                        texto para minúsculas (para pesquisa robusta).
                    </li>
                    <li>
                        <code>encontrarUC(input)</code> — pesquisa local no JSON
                        de UCs, retorna correspondência exata ou múltiplas opções.
                    </li>
                    <li>
                        <code>consolidarAvaliacoes(avaliacoes)</code> — agrupa avaliações
                        com mesma descrição e datas próximas.
                    </li>
                    <li>
                        <code>sendMessage()</code> — rotina principal que processa
                        a mensagem do utilizador, incluindo:
                        <ul class="list-disc list-inside ml-6 mt-1">
                            <li>detecção de comandos ("mudar de UC");</li>
                            <li>gestão da fase de seleção;</li>
                            <li>preparação do contexto e envio ao LLM;</li>
                            <li>atualização do histórico local e UI.</li>
                        </ul>
                    </li>
                </ul>

                <DocsCallout
                    variant="info"
                    title="APIs globais e dependências"
                    client:load
                >
                    <p class="text-sm text-muted-foreground">
                        O componente utiliza a variável global <code
                            >window.apifree.chat()</code
                        > para chamar o modelo LLM. Esta API deve ser inicializada
                        externamente (p. ex., num <code>onMounted()</code> do layout
                        principal).
                    </p>
                </DocsCallout>

                <h4 class="mt-8 font-semibold">
                    Eventos customizados (se expandidos)
                </h4>
                <p class="text-sm text-muted-foreground mt-2">
                    Embora o componente atual não emita eventos para o exterior,
                    recomenda-se adicionar suporte futuro a:
                </p>
                <ul
                    class="list-disc list-inside text-sm text-muted-foreground mt-2"
                >
                    <li>
                        <code>@message-sent</code> — disparado após o envio de cada
                        mensagem do utilizador;
                    </li>
                    <li>
                        <code>@reply-received</code> — disparado quando o LLM devolve
                        uma resposta válida;
                    </li>
                    <li>
                        <code>@uc-changed</code> — disparado quando o utilizador
                        muda de UC.
                    </li>
                </ul>

                <DocsCallout
                    variant="info"
                    title="Extensão recomendada"
                    client:load
                >
                    <p class="text-sm text-muted-foreground">
                        Estes eventos são úteis se o componente for integrado em
                        dashboards, onde se possa registar a interação com
                        analytics, ou sincronizar o estado da conversa com um
                        store global (Pinia, Zustand, etc.).
                    </p>
                </DocsCallout>
            </tbody>

            <!-- ============================================================= -->
            <!-- Componentes Internos -->
            <!-- ============================================================= -->
            <DocsSection
                id="componentes-internos"
                title="🧩 Componentes Internos"
                client:load
            >
                <p class="text-muted-foreground mb-4">
                    O <strong>Chatbot.vue</strong> utiliza um conjunto mínimo de
                    componentes de UI reutilizáveis do sistema <code
                        >@/components/ui</code
                    >. Cada um desempenha um papel bem definido na estrutura da
                    interface.
                </p>

                <h4 class="font-semibold mt-4">1. <code>Button</code></h4>
                <p class="text-sm text-muted-foreground">
                    Utilizado no botão de envio da mensagem. Implementa estados
                    de carregamento e desativação.
                </p>
                <CodeBlock
                    language="vue"
                    code={`<Button type="submit" :disabled="loading || !userInput.trim()" class="h-11 px-6">
  <span v-if="!loading">Enviar</span>
  <span v-else class="flex items-center gap-2">
    <span class="w-4 h-4 border-2 border-current border-t-transparent rounded-full animate-spin"></span>
    A enviar
  </span>
</Button>`}
                />

                <h4 class="font-semibold mt-6">2. <code>Input</code></h4>
                <p class="text-sm text-muted-foreground">
                    Campo de entrada principal. Reativo através de <code
                        >v-model</code
                    >, suporta o envio com <code>@submit.prevent</code>.
                </p>

                <h4 class="font-semibold mt-6">3. <code>Card</code></h4>
                <p class="text-sm text-muted-foreground">
                    Contém cada bolha de mensagem, distinguindo entre utilizador
                    e assistente com base na classe CSS. As sombras e bordas
                    variam conforme o papel da mensagem.
                </p>

                <h4 class="font-semibold mt-6">4. <code>Badge</code></h4>
                <p class="text-sm text-muted-foreground">
                    Exibe o estado atual da conversa (“A selecionar” / “Em
                    conversa”). Pode ser substituído por um componente <code
                        >StatusDot</code
                    > customizado, caso pretendas consistência visual em dashboards.
                </p>

                <h4 class="font-semibold mt-6">5. Indicador de “typing”</h4>
                <p class="text-sm text-muted-foreground">
                    Representado por três pontos animados (<code
                        >.animate-bounce</code
                    >) dentro de um <code>Card</code>. O efeito é puramente
                    visual e ativado por <code>isTyping.value = true</code>.
                </p>

                <CodeBlock
                    language="html"
                    code={`<div v-if="isTyping" class="flex gap-3 animate-in fade-in slide-in-from-bottom-4 duration-300">
  <div class="w-8 h-8 rounded-full bg-muted flex items-center justify-center flex-shrink-0 mt-1">
    <span class="text-sm">🤖</span>
  </div>
  <Card class="px-4 py-3 bg-card border shadow-sm">
    <div class="flex gap-1">
      <div class="w-2 h-2 rounded-full bg-muted-foreground/40 animate-bounce" style="animation-delay: 0ms"></div>
      <div class="w-2 h-2 rounded-full bg-muted-foreground/40 animate-bounce" style="animation-delay: 150ms"></div>
      <div class="w-2 h-2 rounded-full bg-muted-foreground/40 animate-bounce" style="animation-delay: 300ms"></div>
    </div>
  </Card>
</div>`}
                />

                <DocsCallout
                    variant="info"
                    title="Estrutura modular"
                    client:load
                >
                    <p class="text-sm text-muted-foreground">
                        Todos os subcomponentes estão organizados de forma que
                        podem ser substituídos sem alterar a lógica principal.
                        Isto permite que o mesmo motor de chat seja usado em
                        temas ou frameworks diferentes (por exemplo, Tailwind ou
                        Vuetify).
                    </p>
                </DocsCallout>

                <h4 class="font-semibold mt-6">
                    6. <code>messagesContainer</code>
                </h4>
                <p class="text-sm text-muted-foreground">
                    Elemento DOM referenciado via <code>ref</code> e utilizado pelo
                    método <code>scrollToBottom()</code>
                    para garantir visibilidade da última mensagem. Em dispositivos
                    móveis, o comportamento “scroll-smooth” é ativado por <code
                        >nextTick()</code
                    > para evitar jumps.
                </p>

                <h4 class="font-semibold mt-6">
                    7. <code>messages</code> list
                </h4>
                <p class="text-sm text-muted-foreground">
                    A renderização condicional de mensagens alterna entre layout
                    espelhado (<code>flex-row-reverse</code>) para o utilizador
                    e normal para o assistente. Cada mensagem inclui avatar,
                    corpo (Card) e timestamp formatado.
                </p>

                <CodeBlock
                    language="vue"
                    code={`<div v-for="(msg, i) in messages" :key="i"
  class="flex gap-3 animate-in fade-in slide-in-from-bottom-4 duration-500"
  :class="msg.role === 'user' ? 'flex-row-reverse' : 'flex-row'">
  <!-- Avatar -->
  <div class="w-8 h-8 rounded-full flex items-center justify-center flex-shrink-0 mt-1"
    :class="msg.role === 'user' ? 'bg-primary text-primary-foreground' : 'bg-muted'">
    <span class="text-sm">{{ msg.role === 'user' ? '👤' : '🤖' }}</span>
  </div>
  <!-- Bubble -->
  <div class="flex flex-col gap-1 max-w-[85%]" :class="msg.role === 'user' ? 'items-end' : 'items-start'">
    <Card class="px-4 py-3 shadow-sm" :class="msg.role === 'user' ? 'bg-primary text-primary-foreground' : 'bg-card border'">
      <p class="text-sm leading-relaxed whitespace-pre-wrap break-words">{{ msg.content }}</p>
    </Card>
    <span class="text-xs text-muted-foreground px-1">{{ formatTime(msg.timestamp) }}</span>
  </div>
</div>`}
                />
            </DocsSection>
            <!-- ============================================================= -->
            <!-- Estados e Lógica Interna -->
            <!-- ============================================================= -->
            <DocsSection
                id="estado-logica"
                title="📈 Estados e Lógica Interna"
                client:load
            >
                <p class="text-muted-foreground mb-6">
                    O <strong>Chatbot.vue</strong> implementa uma máquina de estados
                    simples que governa o comportamento global do componente. A lógica
                    principal é declarativa e gira em torno de
                    <em>fases de interação</em> — iniciando com a seleção da UC e
                    progredindo para a conversa guiada.
                </p>

                <h4 class="font-semibold mt-4">Ciclo de vida e fases</h4>
                <ul
                    class="list-disc list-inside text-sm text-muted-foreground mt-2"
                >
                    <li>
                        <strong>Fase “selecionar”</strong> — o chatbot espera que
                        o utilizador indique uma UC por nome ou sigla;
                    </li>
                    <li>
                        <strong>Fase “chat”</strong> — após a seleção, o bot permite
                        perguntas relacionadas com essa UC;
                    </li>
                    <li>
                        <strong>Fallback</strong> — se uma UC deixa de estar acessível
                        (dados inconsistentes), o estado regressa a “selecionar”.
                    </li>
                </ul>

                <CodeBlock
                    language="ts"
                    code={`const fase = ref<'selecionar' | 'chat'>('selecionar')
const ucSelecionada = ref<any | null>(null)

watch(fase, (novaFase) => {
  if (novaFase === 'selecionar') {
    messages.value.push({
      role: 'assistant',
      content: 'Olá! Diz-me a sigla ou nome da UC sobre a qual queres saber mais.',
      timestamp: new Date()
    })
  }
})`}
                />

                <h4 class="font-semibold mt-6">
                    Gestão de mensagens e normalização
                </h4>
                <p class="text-sm text-muted-foreground mt-2">
                    O histórico é mantido em memória reativa através de <code
                        >messages</code
                    >. Cada mensagem tem metadados mínimos e é limpa de espaços
                    redundantes ou caracteres invisíveis.
                </p>

                <CodeBlock
                    language="ts"
                    code={`function addMessage(role: 'user' | 'assistant', content: string) {
  messages.value.push({
    role,
    content: content.trim(),
    timestamp: new Date()
  })
  nextTick(scrollToBottom)
}`}
                />

                <h4 class="font-semibold mt-6">Deteção e seleção de UC</h4>
                <p class="text-sm text-muted-foreground">
                    A função <code>encontrarUC</code> usa normalização de texto (sem
                    acentos e minúsculas) para comparar o input com nomes e siglas
                    de UCs. Suporta correspondência parcial e devolve múltiplas opções
                    se necessário.
                </p>

                <CodeBlock
                    language="ts"
                    code={`function encontrarUC(input: string) {
  const termo = normalize(input)
  const correspondencias = ucsData.filter(
    uc => normalize(uc.nome).includes(termo) || normalize(uc.sigla) === termo
  )
  if (correspondencias.length === 1) return correspondencias[0]
  if (correspondencias.length > 1) {
    addMessage('assistant', 'Foram encontradas várias UCs: ' +
      correspondencias.map(u => u.sigla).join(', ') + '. Podes especificar melhor?')
    return null
  }
  addMessage('assistant', 'Não encontrei nenhuma UC com esse nome. Tenta novamente.')
  return null
}`}
                />

                <h4 class="font-semibold mt-6">
                    Integração com o LLM (via API)
                </h4>
                <p class="text-sm text-muted-foreground mb-3">
                    Quando a UC está selecionada e o utilizador envia uma
                    pergunta, a mensagem é enviada para o endpoint <code
                        >/api/chat</code
                    >. Este endpoint formata o contexto e comunica com o modelo
                    LLM definido (p.ex., GPT-4, Claude, Mistral, etc.).
                </p>

                <CodeBlock
                    language="ts"
                    code={`async function sendMessage() {
  const input = userInput.value.trim()
  if (!input) return
  addMessage('user', input)
  userInput.value = ''
  isTyping.value = true

  if (fase.value === 'selecionar') {
    const uc = encontrarUC(input)
    if (uc) {
      ucSelecionada.value = uc
      fase.value = 'chat'
      addMessage('assistant', \`Selecionada a UC \${uc.sigla} — \${uc.nome}\`)
      addMessage('assistant', 'Podes agora perguntar sobre avaliações, docentes, etc.')
    }
    isTyping.value = false
    return
  }

  try {
    const { data } = await axios.post('/api/chat', {
      prompt: input,
      uc: ucSelecionada.value,
    })
    addMessage('assistant', data.reply)
  } catch (err) {
    addMessage('assistant', '⚠️ Ocorreu um erro ao processar a tua pergunta. Tenta novamente.')
  } finally {
    isTyping.value = false
  }
}`}
                />

                <DocsCallout
                    variant="warning"
                    title="Gestão de erros"
                    client:load
                >
                    <p class="text-sm text-muted-foreground">
                        Todos os erros de rede, parsing ou resposta inesperada
                        são capturados e traduzidos numa mensagem humanizada.
                        Isto evita falhas silenciosas e mantém a UX fluida mesmo
                        quando o LLM ou o endpoint estão offline.
                    </p>
                </DocsCallout>

                <h4 class="font-semibold mt-6">Formatação e contexto</h4>
                <p class="text-sm text-muted-foreground">
                    O endpoint serverless inclui no prompt o contexto formatado
                    da UC (descrição, objetivos, avaliações consolidadas e corpo
                    docente). Isso garante que as respostas são contextualizadas
                    e factualmente limitadas à UC selecionada.
                </p>

                <CodeBlock
                    language="ts"
                    code={`const contexto = \`
UC: \${uc.sigla} — \${uc.nome}
Objetivos: \${uc.objetivos}
Avaliações: \${uc.avaliacoes.map(a => a.descricao + ' (' + a.peso + '%)').join(', ')}
Docentes: \${uc.docentes.join(', ')}
\`

const { data } = await axios.post('/api/chat', {
  prompt: 'Responde com base apenas neste contexto:\n' + contexto + '\n\nPergunta: ' + input
})`}
                />
            </DocsSection>

            <!-- ============================================================= -->
            <!-- Decisões de Design -->
            <!-- ============================================================= -->
            <DocsSection
                id="design-decisions"
                title="🧠 Decisões de Design"
                client:load
            >
                <p class="text-muted-foreground mb-6">
                    O <strong>Chatbot</strong> foi concebido com base em três princípios:
                    <em>autonomia local</em>,
                    <em>simplicidade cognitiva</em> e <em
                        >neutralidade de framework</em
                    >. Esta secção explica as decisões arquitetónicas e os
                    trade-offs considerados.
                </p>

                <h4 class="font-semibold mt-4">1. Autonomia local</h4>
                <p class="text-sm text-muted-foreground">
                    O componente gere o seu próprio estado interno e não depende
                    de um store global. Esta escolha reduz a complexidade e
                    permite que o Chatbot seja usado isoladamente (por exemplo,
                    numa página estática com fallback local sem rede).
                </p>

                <h4 class="font-semibold mt-6">2. Simplicidade cognitiva</h4>
                <p class="text-sm text-muted-foreground">
                    A lógica de fluxo é legível e orientada a fases
                    (“selecionar” / “chat”). Evita-se FSMs complexas, mas
                    mantém-se previsibilidade e rastreabilidade no
                    comportamento.
                </p>

                <h4 class="font-semibold mt-6">3. Neutralidade de framework</h4>
                <p class="text-sm text-muted-foreground">
                    Apesar de implementado em Vue 3, o design é suficientemente
                    genérico para ser portado para React ou Svelte. O core
                    (gestão de UC, normalização e API calls) é completamente
                    independente de Vue.
                </p>

                <h4 class="font-semibold mt-6">
                    4. User Experience (UX) consistente
                </h4>
                <p class="text-sm text-muted-foreground">
                    O estilo segue o mesmo sistema visual de todos os
                    componentes do projeto (botões, cards, etc.). A experiência
                    é intencionalmente minimalista e sem distracções — o foco é
                    no conteúdo da resposta.
                </p>

                <h4 class="font-semibold mt-6">5. Comunicação com o LLM</h4>
                <p class="text-sm text-muted-foreground">
                    A API intermediária (<code>/api/chat</code>) atua como
                    camada de controlo. Isso previne injeção direta de prompts
                    pelo cliente e permite aplicar políticas de filtragem ou
                    rate-limiting antes de chegar ao modelo.
                </p>

                <h4 class="font-semibold mt-6">
                    6. Tratamento de erros humanizado
                </h4>
                <p class="text-sm text-muted-foreground">
                    Mensagens de erro são formuladas de forma empática (“Tenta
                    novamente”, “Ocorreu um erro…”), para não quebrar a imersão
                    da conversa. A priorização de UX sobre logs técnicos é
                    deliberada.
                </p>

                <h4 class="font-semibold mt-6">
                    7. Consolidação de avaliações
                </h4>
                <p class="text-sm text-muted-foreground">
                    A função <code>consolidarAvaliacoes</code> foi desenhada para
                    corrigir inconsistências no JSON de origem, agrupando avaliações
                    duplicadas com base em data e descrição. Isto evita duplicação
                    de informação no prompt e melhora a qualidade das respostas.
                </p>

                <h4 class="font-semibold mt-6">8. Segurança de dados</h4>
                <p class="text-sm text-muted-foreground">
                    Nenhum dado sensível é armazenado ou enviado diretamente. O
                    histórico reside apenas em memória, e pode ser limpo a
                    qualquer momento com um <code>reset()</code> (função recomendada
                    para futura extensão).
                </p>

                <DocsCallout
                    variant="info"
                    title="Resumo das decisões"
                    client:load
                >
                    <ul
                        class="list-disc list-inside text-sm text-muted-foreground"
                    >
                        <li>Arquitetura minimalista e transparente;</li>
                        <li>
                            Separação clara entre UI e lógica de conversação;
                        </li>
                        <li>Sem dependência de estado global;</li>
                        <li>Camada de API controlada e auditável;</li>
                        <li>UX e mensagens humanizadas.</li>
                    </ul>
                </DocsCallout>
            </DocsSection>
            <!-- ============================================================= -->
            <!-- Integração com outras partes do projeto -->
            <!-- ============================================================= -->
            <DocsSection
                id="integracao"
                title="🧰 Integração com outras partes do projeto"
                client:load
            >
                <p class="text-muted-foreground mb-6">
                    O <strong>Chatbot</strong> foi projetado para integrar-se nativamente
                    com o ecossistema existente do projeto, nomeadamente com o ficheiro
                    <code>ucs.json</code>, os endpoints API e os componentes da
                    UI. Esta secção explica como se processa essa integração e
                    como adaptar o componente para novos contextos ou fontes de
                    dados.
                </p>

                <h4 class="font-semibold mt-4">
                    1. Fonte de dados — <code>ucs.json</code>
                </h4>
                <p class="text-sm text-muted-foreground mb-2">
                    O ficheiro <code>/data/ucs.json</code> contém o catálogo de unidades
                    curriculares e é carregado de forma assíncrona via <code
                        >fetch</code
                    > na montagem do componente. A sua estrutura deve seguir o seguinte
                    formato mínimo:
                </p>

                <CodeBlock
                    language="json"
                    code={`[
  {
    "sigla": "ASCN",
    "nome": "Arquitetura de Sistemas de Computação e Redes",
    "perfil": "Exploração de conceitos de redes e sistemas distribuídos...",
    "criterios": ["Trabalho prático", "Exame final"],
    "docentes": ["Prof. A", "Prof. B"],
    "avaliacoes": [
      { "data": "2024-10-01", "descricao": "Entrega TP1" },
      { "data": "2024-11-15", "descricao": "Exame Final" }
    ]
  }
]`}
                />

                <p class="text-sm text-muted-foreground mt-3">
                    Qualquer propriedade adicional presente neste JSON é
                    ignorada, mas pode ser aproveitada no <code>contextoUC</code
                    > enviado para o LLM, caso se deseje enriquecer as respostas.
                </p>

                <DocsCallout
                    variant="info"
                    title="Carregamento local vs remoto"
                    client:load
                >
                    <p class="text-sm text-muted-foreground">
                        Embora o Chatbot utilize <code
                            >fetch("/data/ucs.json")</code
                        >, nada impede que este ficheiro seja servido por uma
                        API externa (ex: <code>/api/ucs</code>). O comportamento
                        permanece idêntico, bastando garantir que o JSON
                        devolvido segue o mesmo esquema.
                    </p>
                </DocsCallout>

                <h4 class="font-semibold mt-6">
                    2. Endpoint de intermediação — <code>/api/chat.ts</code>
                </h4>
                <p class="text-sm text-muted-foreground">
                    O endpoint <code>pages/api/chat.ts</code> atua como um proxy
                    controlado entre o cliente e o modelo LLM externo. O objetivo
                    é evitar exposição direta da chave API e aplicar camadas de validação.
                </p>

                <CodeBlock
                    language="ts"
                    code={`import type { APIRoute } from "astro"

export const POST: APIRoute = async ({ request }) => {
  try {
    const body = await request.json()
    const response = await fetch("https://apifreellm.com/api/openai/v1/chat/completions", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body),
    })
    if (!response.ok) throw new Error('Resposta inválida do modelo')
    const data = await response.json()
    return new Response(JSON.stringify(data), {
      headers: { "Content-Type": "application/json", "Access-Control-Allow-Origin": "*" },
    })
  } catch (err) {
    console.error(err)
    return new Response(JSON.stringify({ error: "Erro na comunicação com o modelo" }), { status: 500 })
  }
}`}
                />

                <p class="text-sm text-muted-foreground mt-2">
                    Esta camada de intermediação é fundamental para manter o
                    controlo sobre:
                </p>
                <ul
                    class="list-disc list-inside text-sm text-muted-foreground mt-2"
                >
                    <li>Gestão de limites de uso (rate limiting);</li>
                    <li>
                        Auditoria de prompts enviados e respostas devolvidas;
                    </li>
                    <li>
                        Substituição futura por modelos locais (ex: Ollama, LM
                        Studio).
                    </li>
                </ul>

                <h4 class="font-semibold mt-6">
                    3. Integração visual e navegação
                </h4>
                <p class="text-sm text-muted-foreground">
                    O Chatbot usa o mesmo sistema de design (botões, badges,
                    cards, etc.) baseado em
                    <strong>shadcn/ui</strong>, garantindo consistência visual
                    em toda a aplicação. A integração no layout global é feita
                    via lazy load, para não sobrecarregar o bundle inicial.
                </p>

                <CodeBlock
                    language="astro"
                    code={`---
import Chatbot from "@/components/Chatbot.vue"
import DocsLayout from "@/layouts/DocsLayout.astro"
---

<DocsLayout title="Assistente de UCs">
  <Chatbot client:load />
</DocsLayout>`}
                />

                <DocsCallout
                    variant="success"
                    title="Boas práticas de integração"
                    client:load
                >
                    <ul
                        class="list-disc list-inside text-sm text-muted-foreground"
                    >
                        <li>
                            Carregar o componente apenas quando a rota
                            “/assistente” for visitada;
                        </li>
                        <li>
                            Servir o JSON de UCs de forma estática (cache de
                            1h);
                        </li>
                        <li>
                            Evitar dependência de APIs externas sem fallback
                            local;
                        </li>
                        <li>
                            Tratar respostas de erro do LLM com mensagens
                            amigáveis.
                        </li>
                    </ul>
                </DocsCallout>
            </DocsSection>

            <!-- ============================================================= -->
            <!-- Testes e Edge Cases -->
            <!-- ============================================================= -->
            <DocsSection id="testes" title="🧪 Testes e Edge Cases" client:load>
                <p class="text-muted-foreground mb-6">
                    O componente foi desenhado para lidar com vários cenários
                    extremos e falhas de comunicação, mantendo sempre uma UX
                    fluida e previsível. Esta secção documenta os principais
                    casos de teste e respetivas estratégias de mitigação.
                </p>

                <h4 class="font-semibold mt-4">1. UC inexistente</h4>
                <p class="text-sm text-muted-foreground mb-2">
                    Quando o utilizador escreve uma sigla ou nome que não
                    corresponde a nenhuma UC, o Chatbot deve responder de forma
                    empática e oferecer alternativas.
                </p>

                <CodeBlock
                    language="ts"
                    code={`test('UC inexistente', async () => {
  userInput.value = 'InexistenteXYZ'
  await sendMessage()
  expect(messages.value[messages.value.length - 1].content)
    .toContain('Não encontrei nenhuma UC')
})`}
                />

                <h4 class="font-semibold mt-6">2. Várias correspondências</h4>
                <p class="text-sm text-muted-foreground mb-2">
                    Quando há várias UCs parecidas, o Chatbot deve listar até
                    três e pedir clarificação.
                </p>

                <CodeBlock
                    language="ts"
                    code={`test('Várias correspondências', async () => {
  userInput.value = 'Comp'
  await sendMessage()
  expect(messages.value[messages.value.length - 1].content)
    .toContain('Qual delas pretendes?')
})`}
                />

                <h4 class="font-semibold mt-6">3. Falha de rede ou LLM</h4>
                <p class="text-sm text-muted-foreground">
                    Caso o endpoint <code>/api/chat</code> esteja em baixo ou a resposta
                    do modelo seja inválida, o Chatbot devolve uma mensagem humanizada
                    e mantém o histórico intacto.
                </p>

                <CodeBlock
                    language="ts"
                    code={`test('Falha de rede', async () => {
  window.apifree = undefined
  userInput.value = 'Quando é o exame final?'
  await sendMessage()
  expect(messages.value[messages.value.length - 1].content)
    .toContain('⚠️')
})`}
                />

                <h4 class="font-semibold mt-6">4. Histórico longo</h4>
                <p class="text-sm text-muted-foreground">
                    O histórico de conversas é truncado a 10 entradas antes de
                    cada chamada ao modelo. Isto previne que prompts fiquem
                    demasiado extensos e evita timeouts no endpoint.
                </p>

                <DocsCallout
                    variant="warning"
                    title="Limite de histórico"
                    client:load
                >
                    <p class="text-sm text-muted-foreground">
                        Se precisares de manter um histórico completo entre
                        sessões, considera persistir o estado em <code
                            >localStorage</code
                        > ou <code>IndexedDB</code> com compressão JSON.
                    </p>
                </DocsCallout>

                <h4 class="font-semibold mt-6">5. Input vazio ou spam</h4>
                <p class="text-sm text-muted-foreground mb-2">
                    O campo de input bloqueia mensagens vazias e impede envios
                    consecutivos enquanto o estado <code>loading</code> é <code
                        >true</code
                    >.
                </p>

                <CodeBlock
                    language="ts"
                    code={`test('Input vazio', async () => {
  userInput.value = '   '
  await sendMessage()
  expect(messages.value.length).toBeGreaterThan(0) // Nenhuma nova mensagem adicionada
})`}
                />

                <h4 class="font-semibold mt-6">
                    6. Consolidação de avaliações duplicadas
                </h4>
                <p class="text-sm text-muted-foreground">
                    O teste garante que a função <code
                        >consolidarAvaliacoes</code
                    > funde períodos contínuos de avaliações repetidas num só intervalo.
                </p>

                <CodeBlock
                    language="ts"
                    code={`test('Consolidação de avaliações duplicadas', () => {
  const avaliacoes = [
    { data: '2024-03-01', descricao: 'Projeto' },
    { data: '2024-03-02', descricao: 'Projeto' },
    { data: '2024-03-15', descricao: 'Exame' }
  ]
  const consolidadas = consolidarAvaliacoes(avaliacoes)
  expect(consolidadas).toEqual([
    { descricao: 'Projeto', periodo: '2024-03-01 até 2024-03-02' },
    { descricao: 'Exame', periodo: '2024-03-15' }
  ])
})`}
                />

                <DocsCallout
                    variant="success"
                    title="Cobertura mínima recomendada"
                    client:load
                >
                    <ul
                        class="list-disc list-inside text-sm text-muted-foreground"
                    >
                        <li>UC inexistente;</li>
                        <li>UC ambígua (várias correspondências);</li>
                        <li>Falha de rede e LLM;</li>
                        <li>Histórico truncado;</li>
                        <li>Input vazio;</li>
                        <li>Consolidação de avaliações duplicadas.</li>
                    </ul>
                </DocsCallout>
            </DocsSection>
            <!-- ============================================================= -->
            <!-- Boas práticas e recomendações -->
            <!-- ============================================================= -->
            <DocsSection
                id="boas-praticas"
                title="💡 Boas práticas e recomendações"
                client:load
            >
                <p class="text-muted-foreground mb-6">
                    O Chatbot foi concebido com foco em clareza, modularidade e
                    robustez. Seguir boas práticas de integração e manutenção
                    garante que o componente se mantenha previsível, performante
                    e fácil de evoluir.
                </p>

                <h4 class="font-semibold mt-4">
                    1. Separação de responsabilidades
                </h4>
                <ul class="list-disc list-inside text-sm text-muted-foreground">
                    <li>
                        Mantém a lógica de IA e comunicação de rede isolada do
                        template visual.
                    </li>
                    <li>
                        Utiliza <code>watch</code> apenas para efeitos colaterais
                        inevitáveis (como scroll automático).
                    </li>
                    <li>
                        Evita mutar o array <code>messages</code> fora de métodos
                        declarados (use helpers internos).
                    </li>
                </ul>

                <h4 class="font-semibold mt-6">2. Performance</h4>
                <ul class="list-disc list-inside text-sm text-muted-foreground">
                    <li>
                        Limita o número de mensagens no histórico a 10–15,
                        conforme capacidade de contexto do modelo.
                    </li>
                    <li>
                        Evita chamadas redundantes ao LLM — verifica se há
                        contexto suficiente localmente antes de enviar.
                    </li>
                    <li>
                        Considera pré-carregar o JSON de UCs em cache via <code
                            >astro:prefetch</code
                        >.
                    </li>
                </ul>

                <h4 class="font-semibold mt-6">3. UX e acessibilidade</h4>
                <ul class="list-disc list-inside text-sm text-muted-foreground">
                    <li>
                        Usa feedback visual (spinner, animações) para comunicar
                        estados de carregamento.
                    </li>
                    <li>
                        Permite enviar mensagens com Enter e Shift+Enter para
                        multiline.
                    </li>
                    <li>
                        Evita que respostas longas causem overflow visual no
                        container de mensagens.
                    </li>
                </ul>

                <h4 class="font-semibold mt-6">4. Resiliência</h4>
                <DocsCallout
                    variant="warning"
                    title="Tratamento de erros"
                    client:load
                >
                    <p class="text-sm text-muted-foreground">
                        Implementa sempre tratamento de erros para rede e
                        respostas inválidas. Mesmo um <em>timeout</em> ou falha de
                        parsing deve devolver uma resposta amigável e orientadora.
                    </p>
                </DocsCallout>

                <h4 class="font-semibold mt-6">5. Segurança</h4>
                <ul class="list-disc list-inside text-sm text-muted-foreground">
                    <li>
                        Evita injeção de conteúdo direto em <code>v-html</code>.
                    </li>
                    <li>
                        Sanitiza prompts e respostas antes de exibir no DOM.
                    </li>
                    <li>
                        Controla o acesso ao endpoint <code>/api/chat</code> com
                        quotas e validação de origem.
                    </li>
                </ul>

                <h4 class="font-semibold mt-6">
                    6. Versionamento e documentação
                </h4>
                <p class="text-sm text-muted-foreground mb-3">
                    Como este componente tende a evoluir rapidamente (novos
                    modelos, prompts, contextos), é essencial documentar
                    alterações de API e comportamento. Recomenda-se manter um
                    ficheiro <code>CHANGELOG.md</code> associado.
                </p>

                <CodeBlock
                    language="md"
                    code={`## v1.2.0 (2025-10-27)
- Adicionado suporte a prompts contextuais.
- Novo mecanismo de consolidação de avaliações.
- Melhor tratamento de erros de rede.
- Atualização da integração com ucs.json.`}
                />

                <DocsCallout
                    variant="success"
                    title="Checklist de manutenção"
                    client:load
                >
                    <ul
                        class="list-disc list-inside text-sm text-muted-foreground"
                    >
                        <li>
                            Testar com 3 a 5 UCs reais e verificar respostas
                            contextualizadas;
                        </li>
                        <li>
                            Monitorizar logs do endpoint <code>/api/chat</code> para
                            exceções;
                        </li>
                        <li>
                            Atualizar descrições e prompts sempre que o
                            currículo mudar;
                        </li>
                        <li>
                            Validar JSON antes de carregar (evita erros
                            silenciosos no front-end).
                        </li>
                    </ul>
                </DocsCallout>
            </DocsSection>

            <!-- ============================================================= -->
            <!-- Extensões futuras / roadmap -->
            <!-- ============================================================= -->
            <DocsSection
                id="roadmap"
                title="🧭 Extensões futuras / roadmap"
                client:load
            >
                <p class="text-muted-foreground mb-6">
                    A arquitetura modular do Chatbot facilita a sua evolução
                    incremental. Esta secção descreve algumas possíveis
                    melhorias e expansões planeadas para versões futuras.
                </p>

                <h4 class="font-semibold mt-4">
                    1. Contexto cruzado entre UCs
                </h4>
                <p class="text-sm text-muted-foreground">
                    Permitir que o Chatbot identifique relações entre UCs (ex:
                    pré-requisitos ou tópicos comuns), oferecendo respostas que
                    agreguem conhecimento transversal.
                </p>

                <h4 class="font-semibold mt-6">2. Histórico persistente</h4>
                <p class="text-sm text-muted-foreground">
                    Implementar armazenamento local (via <code
                        >localStorage</code
                    > ou <code>IndexedDB</code>) para preservar o histórico
                    entre sessões, com opção de exportação em JSON.
                </p>

                <h4 class="font-semibold mt-6">3. Modo multimodal</h4>
                <p class="text-sm text-muted-foreground">
                    Adicionar suporte a mensagens com anexos (ex: PDFs ou
                    imagens), permitindo ao modelo interpretar documentos de
                    avaliação e fornecer feedback contextual.
                </p>

                <h4 class="font-semibold mt-6">
                    4. Integração com calendário institucional
                </h4>
                <p class="text-sm text-muted-foreground">
                    Ligar o Chatbot ao componente <code>Calendar.vue</code> para
                    apresentar prazos e eventos diretamente na conversa.
                </p>

                <h4 class="font-semibold mt-6">5. Painel administrativo</h4>
                <p class="text-sm text-muted-foreground">
                    Criar uma interface interna onde docentes possam visualizar
                    interações, ajustar prompts, e definir respostas padrão para
                    cada UC.
                </p>

                <DocsCallout
                    variant="info"
                    title="Modelo de expansão recomendada"
                    client:load
                >
                    <p class="text-sm text-muted-foreground">
                        Sempre que uma nova funcionalidade for adicionada, deve
                        ser isolada em subcomponentes Vue e documentada
                        separadamente neste mesmo formato de documentação.
                    </p>
                </DocsCallout>
            </DocsSection>

            <!-- ============================================================= -->
            <!-- Preview interativo -->
            <!-- ============================================================= -->
            <DocsSection id="preview" title="💬 Preview interativo" client:load>
                <p class="text-muted-foreground mb-4">
                    Abaixo encontras uma instância interativa do componente <code
                        >Chatbot</code
                    >, carregada diretamente do código-fonte principal. Este
                    exemplo utiliza o endpoint local <code>/api/chat</code> e o ficheiro
                    <code>ucs.json</code> padrão.
                </p>

                <div class="border rounded-2xl p-4 bg-card">
                    <Chatbot1 client:only="vue" />
                </div>

                <DocsCallout
                    variant="info"
                    title="Sandbox de demonstração"
                    client:load
                >
                    <p class="text-sm text-muted-foreground">
                        O preview não guarda histórico entre refreshes. Para
                        testar prompts mais complexos ou integração real, acede
                        à rota dedicada
                        <code>/assistente</code>.
                    </p>
                </DocsCallout>
            </DocsSection>
        </table>
    </DocsSection></DocsLayout
>
